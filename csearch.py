try:
    import numpy as np
    import argparse, os
    import openpyxl
except ImportError:
    os.system('pip install -r requirements.txt')
    import numpy as np
    import argparse, os
    import openpyxl

from openpyxl import Workbook, load_workbook
from openpyxl.styles import Font, PatternFill, Alignment
from openpyxl.styles.borders import Border, Side
from openpyxl.cell.cell import Cell


parser = argparse.ArgumentParser(
    description='''This script is meant to generate a new excel file (or edit a existing one) with a lot of worksheets from input files. Usually generated by copying the "Molecule Group Table" of GaussView.
    '''
)
requiredNamed = parser.add_argument_group('Required named arguments')
requiredNamed.add_argument('-l', '--level', help='Level of the calculation', required=True, nargs='+')
parser.add_argument("-T", "--temperature", help="Set temperature for the Boltzmann Distribution.", action="store", default=298.15)
parser.add_argument("-c", "--cutenergy", help="Set energy you want to cut the conformers in kcal/mol", action="store", default=5)
parser.add_argument("-s", "--silent", help="Print on-screen the results, not saving them in any file", action="store_true", default=False)
parser.add_argument("-v", "--verbose", help="Choose the amount of data you want to be printed on-screen", action="store", default=2, choices=[0, 1, 2, 3], type=int)
parser.add_argument("-o", "--output", help="Change the default output xlsx file.", action="store", default='csearch.xlsx')
parser.add_argument("-n", "--name", help="Define a custom name for the sheet and the title. Default is the name of the directory present in the file path")
parser.add_argument("-i", "--input", help="Change the default input txt file", default='csearch.txt')
parser.add_argument("-nd", "--notdel", help="Don't delete structures with same energy", action="store_true", default=False)
parser.add_argument('-sc', '--scan', help='Input file is a sumup of a scan', action='store_true', default=False)
parser.add_argument('-d', '--description', help='Add a description to your calculation', type=str, nargs='+', default='\n')
parser.add_argument('-a', '--angle', help='Angle to refer all other angle, used for scan only', type=int, default=180)
parser.add_argument('-ff', '--from_file', help='Get input from files generated with a different headline. This has to be defined in the input file as first row.', type=str)
parser.add_argument('-no', '--not_order', action='store_true', help='Use this flag to avoid the ordering of the conformer')

args = parser.parse_args()

## CONTS

R = 1.98720425864083*10**(-3)
T = args.temperature
H = 627.5095
CUTENERGY = args.cutenergy



font_title = Font(color='31869B', bold=True)
bg_title = PatternFill(start_color="BDE0FF", end_color="BDE0FF", fill_type='solid')
tick_bottom_border = Border(bottom=Side(style='thick'))


## FUNCS

def styled_cells(data, ws): 
    for c in data:
        c = Cell(ws, value=c)
        if c.value != '':
            c.font = font_title
            c.fill = bg_title
            c.alignment = Alignment(horizontal='center')
        yield c


def bordered_cells(data, ws, bordering=tick_bottom_border):
    for c in data:
        c = Cell(ws, value=c)
        c.border = bordering
        yield c

def rule_formatting(data, ws):
    """
    Conditional formatting on cells, if relative energy is grater than default value
    """  
    for idx, c in enumerate(data):
        if c:
            c = Cell(ws, value=c)
            try:
                if idx == 4 and c.value >= CUTENERGY and not args.notdel:
                    c.font = Font(color='9A0511')
                    c.fill = PatternFill(start_color="FEC7CE", end_color="FEC7CE", fill_type='solid')
            except:
                pass
            c.alignment = Alignment(horizontal='center')
        yield c


def write_excel(confs, de, bolz, pop, to_del):
    if os.path.exists(args.output):
        wb = load_workbook(args.output)
    else:
        wb = Workbook()

    if not args.name:
        if confs[0, 2].split('/')[3].title() not in wb.sheetnames:
            ws = wb.create_sheet(confs[0, 2].split('/')[3].title())
        else:
            ws = wb[confs[0, 2].split('/')[3].title()]
    else:
        if args.name not in wb.sheetnames:
            ws = wb.create_sheet(args.name)
        else:
            ws = wb[args.name]

    # Title       
    ws['A1'] = f'{confs[0, 2].split("/")[3]}'.title() if not args.name else args.name.title()
    ws.merge_cells("A1:G1")
    ws['A1'].font = Font(color='ffffff', bold=True)
    ws['A1'].fill = PatternFill(start_color='16365C', end_color='16365C', fill_type='solid')
    ws['A1'].alignment = Alignment(horizontal='center')

    # Costrains
    ws.append([])
    ws.append(styled_cells(['', 'T', f'{T} K', '', 'Number of structures retained', f'{confs.shape[0]}', ''], ws))
    ws.append([])
    if args.description != '\n':
        ws.append(styled_cells(['', 'Computational level', ' '.join(args.level), '', 'Description', ' '.join(args.description)], ws))
    else:
        ws.append(styled_cells(['', '', 'Computational level', ' '.join(args.level), '', ''], ws))
    ws.append([])

    if not args.scan:
        ws.append(styled_cells(['Entry', 'Name', 'File path', 'Energy (Hartee)', '∆E (kcal/mol)', 'Bolzmann Distrib.', 'Population (%)'], ws))
    elif args.scan:
        ws.append(styled_cells(['Entry', 'Name', 'File path', 'Angle', 'Energy (kcal/mol)', '∆E (kcal/mol)'], ws))

    for row, entry in enumerate(list(confs)):
        towrite = list(entry) + [de[row], bolz[row], pop[row]]
        ws.append(rule_formatting(towrite, ws))

    # fit to context
    dims = {}
    for row in ws.rows:
        for cell in row:
            if cell.value:
                dims[cell.column_letter] = max((dims.get(cell.column_letter, 0), len(str(cell.value))))    
    for col, value in dims.items():
        ws.column_dimensions[col].width = value

    ws.append(bordered_cells(['', '', '', '', '', '', ''], ws))

    wb.save(args.output)

def make_calculations(file):
    with open(file) as f:
        lines = f.readlines()

    confs = np.array([i.strip().split('\t') for i in lines])
    to_del = []

    
    if not ((not args.notdel) or (not args.scan)):
        tmp = []
        idx_to_del = []
        for idx, i in enumerate(list(confs)):
            if i[-1].astype(np.float64) not in tmp:
                tmp.append(i[-1].astype(np.float64))
            else:
                idx_to_del.append(i[0].astype(np.int8))

        for i in idx_to_del:
            res = np.argwhere(confs[:, 0].astype(np.int8) == i)[0]
            to_del.append(''.join(list(confs[res, 1])))
            confs = np.delete(confs, res, 0)
    

    if args.scan:
        angles = np.array(confs[:, 3][:], dtype='float')
        angles.resize((confs.shape[0]))
        if args.angle != 180:
            angles -= args.angle 
        else:
            if len(set(list(angles > 360))) == 2:
                angles -= args.angle
            elif len(set(list(angles < -360))) == 2:
                angles += args.angle
        confs[:, 3] = angles
    
    if not args.not_order:
        confs = confs[confs[:, 3].argsort()[::-1]] if not args.scan else confs[:, :-1]
    # ∆E, bolzmann
    es = confs[:, -1].astype(np.float64) * H
    de = es-min(es)
    bolz = np.exp(-de/(R*T)) if not args.scan else np.zeros(de.size)
    pop = bolz/np.sum(bolz) * 100 if not args.scan else np.zeros(de.size)

    return confs, de, bolz, pop, list(to_del)

def verbose(confs, de, bolz, pop, level):
    de = de.T
    bolz = bolz.T
    pop = pop.T
    ids_ = confs[:, 0].T
    names = confs[:, 1].T
    filepaths = confs[:, 2].T
    angle = confs[:, 3].T
    e = confs[:, -1].T

    str_dict = {  
        1: (ids_, de, pop) if not args.scan else (ids_, angle, de),
        2: (ids_, names, e, de, pop) if not args.scan else (ids_, names, angle, e, de), 
        3: (ids_, names, filepaths, e, de, bolz, pop) if not args.scan else (ids_, names, filepaths, angle, e, de),
    }
    header = {
        1: '  -  '.join(['Entry','∆E (kcal/mol)', 'Population (%)']) if not args.scan else '  -  '.join(['Entry','Angle', '∆E (kcal/mol)']),
        2: '  -  '.join(['Entry', 'Name', 'Energy (kcal/mol)', '∆E (kcal/mol)', 'Population (%)']) if not args.scan else '  -  '.join(['Entry', 'Name', 'Angle', 'Energy (kcal/mol)', '∆E (kcal/mol)']),
        3: '  -  '.join(['Entry', 'Name', 'File path', 'Energy (Hartree)', '∆E (kcal/mol)', 'Bolzmann Distrib.', 'Population (%)']) if not args.scan else '  -  '.join(['Entry', 'Name', 'File path', 'Angle', 'Energy (kcal/mol)', '∆E (kcal/mol)']),
    }
    v_out = np.vstack(str_dict[level]).T

    print(f'Calculation of Bolzmann Distribution has been made at {args.temperature} K\n')
    print(header[level])
    for i in v_out:
        print('  -  '.join(i))
    print(f'\nThe complete results has{" NOT" if args.silent else ""} been saved in {args.output}')


def get_from_file(filename):
    with open(filename) as f:
        lines = f.readlines()
    confs = np.array([i.strip().split(',') for i in lines])
    if os.path.exists(args.output):
        wb = load_workbook(args.output)
    else:
        wb = Workbook()

    if not args.name:  
        if confs[1, 2].split('/')[5].title() not in wb.sheetnames:
            ws = wb.create_sheet(confs[1, 2].split('/')[5].title())
        else:
            ws = wb[confs[1, 2].split('/')[5].title()]
    else:
        if args.name not in wb.sheetnames:
            ws = wb.create_sheet(args.name)
        else:
            ws = wb[args.name]

    ws.append([])
    if args.description != '\n':
        ws.append(styled_cells(['', 'Computational level', ' '.join(args.level), '', 'Description', ' '.join(args.description)], ws))
    else:
        ws.append(styled_cells(['', '', 'Computational level', ' '.join(args.level), '', ''], ws))
    ws.append([])

    ws.append(styled_cells(confs[0,:], ws))
    for row, entry in enumerate(confs[1:, :]):
        ws.append(rule_formatting(entry, ws))

    # fit to context
    dims = {}
    for row in ws.rows:
        for cell in row:
            if cell.value:
                dims[cell.column_letter] = max((dims.get(cell.column_letter, 0), len(str(cell.value))))    
    for col, value in dims.items():
        ws.column_dimensions[col].width = value

    ws.append(bordered_cells(['', '', '', '', '', '', ''], ws))

    wb.save(args.output)


def main():
    if args.from_file:
        get_from_file(args.from_file)
    else:
        confs, de, bolz, pop, to_del = make_calculations(args.input)
        if not args.silent:
            write_excel(confs, de, bolz, pop, to_del)
        deleted_conf = "\n- ".join(to_del)
        print(f'This are the configuration has been ignored since they have the same energy of another conformer:\n- {deleted_conf}\n')
        if args.verbose>0 or args.silent:
            verbose(confs, de, bolz, pop, args.verbose)
        



if __name__ == '__main__':
    main()
